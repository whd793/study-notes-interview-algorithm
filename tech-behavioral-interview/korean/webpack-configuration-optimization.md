# Webpack 구성을 어떻게 최적화하셨나요?

대규모 기업용 웹 애플리케이션에서 빌드 시간이 길고 번들 크기가 커서 로딩 성능이 저하되는 문제가 있었습니다. 이를 해결하기 위해 Webpack 구성을 체계적으로 최적화했습니다.

먼저 webpack-bundle-analyzer를 사용하여 번들 구성을 분석했습니다. 이를 통해 어떤 모듈이 가장 많은 공간을 차지하는지 파악하고, moment.js, lodash와 같은 큰 라이브러리에서 불필요한 부분을 제거하는 작업부터 시작했습니다.

코드 스플리팅을 적극 활용하여 초기 로드 시 필요한 코드만 다운로드되도록 했습니다. React.lazy와 Suspense를 활용한 동적 임포트를 구현하고, 라우트 기반 분할과 함께 주요 기능별 청크를 생성했습니다. 이를 통해 초기 로드 시간을 40% 단축했습니다.

캐싱 전략을 개선했습니다. contenthash를 파일명에 포함시켜 내용이 변경된 파일만 새로 다운로드되도록 했고, runtime chunk를 분리하여 애플리케이션 코드 변경 시에도 벤더 청크의 캐싱이 유지되도록 했습니다.

빌드 성능 향상을 위해 여러 최적화를 적용했습니다. babel-loader에 cacheDirectory 옵션을 활성화하고, thread-loader를 사용하여 트랜스파일링을 병렬로 처리했습니다. 개발 중에는 source-map 생성을 최소화하고, 프로덕션 빌드에서는 terser-webpack-plugin의 병렬 처리 옵션을 활성화했습니다.

불필요한 폴리필을 줄이기 위해 @babel/preset-env의 useBuiltIns 옵션을 'usage'로 설정하여 실제 사용하는 기능에 필요한 폴리필만 포함되도록 했습니다. 또한 browserslist 구성을 최적화하여 지원 브라우저 범위를 명확히 정의했습니다.

개발 경험 향상을 위해 hot module replacement를 구성하고, FastRefreshPlugin을 적용하여 상태를 유지하면서 코드 변경사항이 즉시 반영되도록 했습니다.

모듈 해결 과정을 최적화하기 위해 resolve.extensions와 resolve.alias 옵션을 설정하여 파일 검색 범위를 줄였습니다. 이는 특히 대규모 모노레포 환경에서 빌드 시간 단축에 효과적이었습니다.

환경별 구성 관리를 위해 webpack-merge를 활용하여 공통, 개발, 프로덕션 설정을 분리했습니다. 이를 통해 각 환경에 최적화된 설정을 유지하면서 중복 코드를 줄일 수 있었습니다.

이러한 종합적인 최적화를 통해 개발 환경 빌드 시간은 65% 단축되었고, 프로덕션 번들 크기는 47% 감소했습니다. 이는 개발자 생산성 향상과 사용자 경험 개선으로 이어졌습니다.