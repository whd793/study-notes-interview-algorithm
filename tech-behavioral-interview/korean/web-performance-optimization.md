# 웹 성능 최적화를 위해 어떤 기법을 적용하셨나요?

전자상거래 플랫폼에서 페이지 로드 시간과 상호작용 지연이 사용자 이탈의 주요 원인으로 확인되어, 웹 성능 최적화 프로젝트를 진행했습니다.

먼저 현재 성능을 측정하고 병목 지점을 파악했습니다. Lighthouse, WebPageTest, Chrome DevTools를 사용하여 주요 성능 지표(LCP, FID, CLS, TTI 등)를 측정하고, 성능 기준선을 설정했습니다. 특히 모바일 환경에서의 성능에 중점을 두었습니다.

번들 크기 최적화를 위해 여러 기법을 적용했습니다. 코드 스플리팅을 구현하여 초기 로드에 필요한 JavaScript만 다운로드하도록 했습니다. React.lazy와 Suspense를 활용해 라우트 기반 분할을 적용했고, 중요하지 않은 컴포넌트는 지연 로딩으로 처리했습니다. 또한 트리 셰이킹을 통해 사용하지 않는 코드를 제거했습니다.

이미지 최적화에 많은 노력을 기울였습니다. WebP와 AVIF 같은 최신 포맷을 도입하고, 반응형 이미지 기법(srcset, sizes)을 적용했습니다. 중요하지 않은 이미지는 지연 로딩을 구현하고, 이미지 CDN을 활용하여 자동 최적화와 전역 배포를 실현했습니다.

렌더링 성능 개선을 위해 React 애플리케이션의 불필요한 리렌더링을 줄였습니다. React.memo, useMemo, useCallback을 전략적으로 사용하여 컴포넌트와 계산 결과를 메모이제이션했습니다. 또한 가상 스크롤을 도입하여 대량의 목록 데이터를 효율적으로 렌더링했습니다.

네트워크 최적화를 위해 API 응답을 압축하고, HTTP/2 프로토콜을 활성화했습니다. 또한 중요한 API 응답을 캐싱하여 반복 요청을 줄였고, GraphQL을 도입하여 오버페칭 문제를 해결했습니다.

주요 렌더링 경로를 최적화했습니다. CSS는 중요한 스타일만 인라인으로 포함시키고 나머지는 비동기로 로드했습니다. 폰트 로딩 전략을 개선하여 FOUT(Flash of Unstyled Text)를 방지했고, preload, prefetch, preconnect 힌트를 전략적으로 사용했습니다.

사용자 체감 성능을 높이기 위한 UX 패턴도 적용했습니다. 스켈레톤 스크린을 구현하여 로딩 중인 콘텐츠의 레이아웃을 미리 표시했고, 낙관적 UI 업데이트로 API 응답을 기다리는 동안 사용자 상호작용에 즉시 피드백을 제공했습니다.

오프라인 지원과 복원력을 강화했습니다. Service Worker를 구현하여 핵심 리소스를 캐싱했고, 네트워크 불안정 상황에서도 기본 기능이 작동하도록 했습니다. 또한 IndexedDB를 활용하여 장바구니 정보를 로컬에 저장하는 오프라인 장바구니 기능을 구현했습니다.

지속적인 성능 모니터링 시스템을 구축했습니다. RUM(Real User Monitoring)을 통해 실제 사용자 환경에서의 성능 데이터를 수집하고, CI/CD 파이프라인에 성능 테스트를 통합하여 성능 회귀를 방지했습니다.

이러한 종합적인 최적화 작업 결과, 모바일에서의 LCP가 5.2초에서 1.8초로 감소했고, CLS가 0.25에서 0.05로 개선되었습니다. 이는 전환율 28% 증가, 이탈률 35% 감소라는 비즈니스 성과로 이어졌습니다.