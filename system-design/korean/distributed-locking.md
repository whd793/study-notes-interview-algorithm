# 분산 잠금 메커니즘 설계

분산 잠금 메커니즘은 분산 시스템 전반에 걸쳐 공유 리소스에 대한 액세스를 조정하여 경쟁 조건을 방지하고 일관된 작업을 보장합니다. 이러한 메커니즘은 확장성을 제한하는 중앙화된 제어 지점 없이 상호 배제를 제공합니다.

주요 요구 사항으로는 상호 배제(한 번에 한 클라이언트만 잠금을 보유할 수 있음), 교착 상태 방지(무기한 리소스 차단 방지), 활성(실패에도 불구하고 잠금이 결국 부여됨), 장애 허용성(잠금 서버가 실패해도 시스템이 작동 상태 유지)이 있습니다.

구현 접근 방식은 일관성 요구 사항과 규모에 따라 다양합니다: 데이터베이스 기반 잠금은 공유 테이블에 대한 원자적 작업을 사용하여 강력한 일관성을 제공하지만 처리량이 제한됩니다; Redis나 etcd와 같은 분산 키-값 저장소는 낙관적 잠금 패턴으로 더 높은 성능을 제공합니다; Apache ZooKeeper나 Google의 Chubby와 같은 전문 서비스는 고급 조정 기능을 제공합니다.

Redis 기반 접근 방식은 NX(존재하지 않는 경우 설정)와 만료 시간이 있는 SET과 같은 원자적 명령을 사용하여 잠금을 구현합니다. 이 패턴에는 잠금 보유자만 잠금을 해제할 수 있도록 보장하는 고유한 토큰이 포함됩니다. 단순하고 고성능이지만, 이는 신중한 타임아웃 관리와 잠금 연장을 위한 추가 메커니즘이 필요합니다.

ZooKeeper 기반 잠금은 임시 순차 노드를 사용하며, 클라이언트는 노드를 생성하고 선행 노드를 모니터링하여 잠금 획득을 결정합니다. 이 접근 방식은 클라이언트 세션이 종료될 때 임시 노드가 자동으로 사라져 클라이언트 실패 시 자동 잠금 해제를 제공하므로 서버 실패를 우아하게 처리합니다.

펜싱 토큰 - 잠금 획득 시 제공되는 단조 증가 값 - 은 여러 클라이언트가 잠금을 보유하고 있다고 믿는 분할 뇌 시나리오로부터 보호합니다. 리소스 관리자는 토큰 값을 확인하고 오래된 토큰으로부터의 작업을 거부하여 네트워크 파티션 중에도 동시 액세스를 방지합니다.

재진입 가능한 잠금(동일한 클라이언트가 동일한 잠금을 여러 번 획득할 수 있음)은 클라이언트 식별 및 잠금 카운팅 메커니즘이 필요합니다. 이는 복잡성을 추가하지만 재귀적 작업에서 교착 상태를 방지합니다. 마찬가지로, 읽기/쓰기 잠금은 독점적인 쓰기 액세스와 공유된 읽기 액세스를 구분하여 읽기 위주 워크로드의 동시성을 향상시킵니다.

실용적인 분산 잠금 구현은 장애 시나리오를 처리해야 합니다: 잠금을 보유한 상태에서의 클라이언트 충돌, 잠금 서비스 실패, 네트워크 파티션. 기술로는 자동 만료 잠금, 리스 기반 접근 방식, 실패를 감지하고 복구하기 위한 하트비트 메커니즘이 있습니다. 포괄적인 모니터링 및 교착 상태 감지 시스템은 프로덕션 배포에 필수적입니다.