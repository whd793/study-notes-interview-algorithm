# 프로그래머스: 전화번호 목록 문제에 대한 인터뷰 답변

## 문제 설명
전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하는 문제입니다. 전화번호가 담긴 배열 phone_book이 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 반환해야 합니다.

## 접근 방법
이 문제는 두 가지 주요 접근법으로 해결할 수 있습니다:

### 1. 정렬 후 인접한 요소만 비교
전화번호를 사전순으로 정렬하면, 접두어 관계에 있는 번호들은 서로 인접하게 됩니다. 따라서 정렬 후 인접한 두 번호만 비교하면 모든 접두어 관계를 확인할 수 있습니다.

### 2. 해시 테이블(Set) 활용
모든 전화번호를 해시 테이블에 저장한 후, 각 번호의 모든 가능한 접두어가 다른 번호로 존재하는지 확인합니다.

여기서는 더 효율적인 정렬 접근법을 설명하겠습니다.

## 코드 구현 (정렬 접근법)
```python
def solution(phone_book):
    # 전화번호 목록을 사전순으로 정렬
    phone_book.sort()
    
    # 인접한 두 번호만 비교
    for i in range(len(phone_book) - 1):
        # 현재 번호가 다음 번호의 접두어인지 확인
        if phone_book[i + 1].startswith(phone_book[i]):
            return False
    
    # 접두어 관계가 없으면 true 반환
    return True
```

## 시간 및 공간 복잡도
- 시간 복잡도: O(n log n) - 정렬에 O(n log n), 비교에 O(n * m)의 시간이 소요됩니다. 여기서 n은, 전화번호의 개수, m은 전화번호의 평균 길이입니다.
- 공간 복잡도: O(1) - 추가 공간을 사용하지 않습니다(정렬 알고리즘의 내부 구현에 따라 다를 수 있음).

## 해시 테이블 접근법
```python
def solution_hash(phone_book):
    # 모든 전화번호를 해시셋에 저장
    number_set = set(phone_book)
    
    # 각 번호의 모든 가능한 접두어 확인
    for number in phone_book:
        for i in range(1, len(number)):
            # 현재 번호의 접두어가 다른 번호로 존재하는지 확인
            prefix = number[:i]
            if prefix in number_set:
                return False
    
    return True
```

이 방법의 시간 복잡도는 O(n * m²)로, n은 전화번호의 개수, m은 전화번호의 평균 길이입니다. 평균적인 상황에서는 정렬 접근법이 더 효율적입니다.

## 엣지 케이스 처리
- 동일한 번호가 여러 번 등장하는 경우: 문제 조건에 따라 처리합니다.
- 빈 배열: 접두어 관계가 없으므로 true 반환.

## 최적화 고려사항
정렬 접근법은 이미 최적화되어 있습니다. 다만, 전화번호의 길이가 매우 길고 수가 적다면 해시 접근법이 더 효율적일 수 있습니다.

## 면접 팁
이 문제는 해시를 이용한 문제이지만, 정렬을 통한 해결법이 더 효율적일 수 있다는 점을 보여주는 좋은 예시입니다. 면접에서는 두 가지 접근법을 모두 설명하고 각각의 시간 복잡도와 장단점을 비교하면 좋은 인상을 줄 수 있습니다.