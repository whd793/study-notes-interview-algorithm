# Two Sum 문제에 대한 인터뷰 답변

## 문제 설명
정수 배열과 타겟 숫자가 주어졌을 때, 배열에서 두 수의 합이 타겟 숫자가 되는 인덱스 두 개를 찾는 문제입니다.

## 접근 방법
이 문제는 브루트 포스 방식으로 이중 반복문을 사용하여 O(n²) 시간 복잡도로 해결할 수 있지만, 해시 맵(딕셔너리)을 활용하면 O(n) 시간 복잡도로 더 효율적으로 해결할 수 있습니다.

해시 맵을 사용하는 알고리즘 흐름은 다음과 같습니다:
1. 빈 해시 맵을 생성합니다.
2. 배열을 순회하면서 각 원소에 대해:
   - 현재 원소와 타겟의 차이(보수)를 계산합니다.
   - 해시 맵에 이 보수가 있는지 확인합니다.
   - 보수가 존재하면, 현재 인덱스와 해시 맵에 저장된 보수의 인덱스를 반환합니다.
   - 보수가 존재하지 않으면, 현재 원소와 인덱스를 해시 맵에 저장합니다.

## 코드 구현
```python
def two_sum(nums, target):
    # 값과 인덱스를 저장할 해시 맵
    num_map = {}
    
    # 배열 순회
    for i, num in enumerate(nums):
        # 타겟에서 현재 숫자를 뺀 보수 계산
        complement = target - num
        
        # 보수가 해시 맵에 있는지 확인
        if complement in num_map:
            # 보수의 인덱스와 현재 인덱스 반환
            return [num_map[complement], i]
        
        # 현재 숫자와 인덱스를 해시 맵에 저장
        num_map[num] = i
    
    # 합이 타겟이 되는 두 수가 없는 경우
    return []
```

## 시간 및 공간 복잡도
- 시간 복잡도: O(n) - 배열을 한 번만 순회합니다.
- 공간 복잡도: O(n) - 최악의 경우 해시 맵에 n개의 원소를 저장합니다.

## 최적화 고려사항
입력 배열이 이미 정렬되어 있다면, 투 포인터 접근법을 사용하여 추가 공간 없이 O(n) 시간 복잡도로 해결할 수 있습니다. 하지만 원래 인덱스를 유지해야 하는 경우 정렬 후에는 원래 인덱스를 찾기 어려워집니다.

## 엣지 케이스 처리
- 빈 배열
- 합이 타겟이 되는 두 수가 없는 경우
- 동일한 원소를 두 번 사용할 수 없음 (문제 요구사항에 따라 다를 수 있음)

이 문제는 해시 맵의 활용과 시간 복잡도 최적화의 좋은 예시이며, 실제 인터뷰에서 접근법과 코드 구현을 명확히 설명하는 것이 중요합니다.