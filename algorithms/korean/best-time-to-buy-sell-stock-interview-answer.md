# Best Time to Buy and Sell Stock(주식 거래 최적 시점) 문제에 대한 인터뷰 답변

## 문제 설명
주식 가격이 담긴 배열이 주어집니다. 배열의 i번째 원소는 i일의 주식 가격을 나타냅니다. 한 번의 거래(하루에 주식 구매 후 다른 날에 판매)로 얻을 수 있는 최대 이익을 구하는 문제입니다. 만약 이익을 얻을 수 없다면 0을 반환합니다.

## 접근 방법
이 문제는 한 번의 배열 순회로 해결할 수 있습니다. 핵심 아이디어는 현재까지 본 가장 낮은 가격을 기억하고, 각 날짜에서 주식을 판매했을 때의 이익을 계산하는 것입니다.

알고리즘 흐름은 다음과 같습니다:
1. 두 변수를 초기화합니다: `min_price`(현재까지 본 최소 가격)와 `max_profit`(현재까지의 최대 이익).
2. 배열을 순회하면서 각 가격에 대해:
   - 현재 가격이 `min_price`보다 낮으면 `min_price`를 갱신합니다.
   - 현재 가격에서 `min_price`를 뺀 값(현재 가능한 이익)이 `max_profit`보다 크면 `max_profit`을 갱신합니다.

## 코드 구현
```python
def max_profit(prices):
    # 예외 처리: 빈 배열 또는 하루만 있는 경우
    if len(prices) <= 1:
        return 0
    
    min_price = prices[0]  # 현재까지 본 최소 가격
    max_profit = 0         # 현재까지의 최대 이익
    
    # 두 번째 날부터 순회
    for i in range(1, len(prices)):
        # 현재 가격과 최소 가격 비교, 갱신
        min_price = min(min_price, prices[i])
        
        # 현재 가격에 판매했을 때의 이익 계산, 최대 이익 갱신
        current_profit = prices[i] - min_price
        max_profit = max(max_profit, current_profit)
    
    return max_profit
```

## 시간 및 공간 복잡도
- 시간 복잡도: O(n) - 배열을 한 번만 순회합니다.
- 공간 복잡도: O(1) - 추가 배열 없이 상수 공간만 사용합니다.

## 최적화 고려사항
현재 알고리즘은 이미 최적화되어 있습니다. 단일 반복문으로 문제를 해결하므로 더 효율적인 방법은 없습니다.

브루트 포스 접근법(모든 가능한 구매-판매 쌍을 검사)은 O(n²) 시간 복잡도를 가지므로 훨씬 비효율적입니다.

## 엣지 케이스 처리
- 빈 배열 또는 하루만 있는 경우: 거래가 불가능하므로 0 반환
- 가격이 계속 하락하는 경우: 이익을 얻을 수 없으므로 0 반환

## 추가 생각할 점
- 이 문제의 변형으로 여러 번 거래할 수 있는 경우나, 거래 횟수에 제한이 있는 경우 등이 있습니다. 그런 경우에는 동적 프로그래밍 접근법을 사용해야 할 수 있습니다.
- 실제 주식 거래에서는 거래 수수료, 세금 등 추가 비용이 발생할 수 있습니다. 이런 요소들도 고려해야 하는 경우 알고리즘을 수정해야 합니다.

이 문제는 배열 순회와 변수 추적을 통한 효율적인 알고리즘 설계를 테스트합니다. 면접에서는 최적화된 접근법을 명확히 설명하고, 브루트 포스 방식과 비교하여 효율성을 논의하는 것이 좋습니다.