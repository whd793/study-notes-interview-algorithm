# 프로그래머스: 더 맵게 문제에 대한 인터뷰 답변

## 문제 설명
매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 다음과 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.

```
섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)
```

Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다. Leo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하는 문제입니다. 단, 모든 음식의 스코빌 지수를 K 이상으로 만들 수 없는 경우에는 -1을 return 합니다.

## 접근 방법
이 문제는 최소 힙(Min Heap)을 사용하여 효율적으로 해결할 수 있습니다. 최소 힙은 가장 작은 원소를 빠르게 찾을 수 있는 자료구조로, 이 문제에서 가장 맵지 않은 두 음식을 찾는 데 적합합니다.

알고리즘의 흐름은 다음과 같습니다:
1. 모든 음식의 스코빌 지수를 최소 힙에 넣습니다.
2. 최소 힙에서 가장 작은 값을 꺼내 K 이상인지 확인합니다.
3. K 미만이면, 두 번째로 작은 값도 꺼내어 새로운 음식을 만들고 힙에 다시 넣습니다.
4. 모든 음식의 스코빌 지수가 K 이상이 될 때까지 2-3을 반복합니다.
5. 힙의 크기가 1이고 여전히 K 미만이면 모든 음식을 K 이상으로 만들 수 없으므로 -1을 반환합니다.

## 코드 구현
```python
import heapq

def solution(scoville, K):
    # 스코빌 지수 배열을 최소 힙으로 변환
    heapq.heapify(scoville)
    mix_count = 0
    
    # 스코빌 지수가 K 이상이 될 때까지 반복
    while len(scoville) >= 2 and scoville[0] < K:
        # 가장 맵지 않은 음식과 두 번째로 맵지 않은 음식을 꺼냄
        first = heapq.heappop(scoville)
        second = heapq.heappop(scoville)
        
        # 새로운 음식 생성
        new_food = first + (second * 2)
        
        # 새로운 음식을 힙에 추가
        heapq.heappush(scoville, new_food)
        mix_count += 1
    
    # 모든 음식의 스코빌 지수가 K 이상인지 확인
    if scoville[0] >= K:
        return mix_count
    else:
        return -1
```

## 시간 및 공간 복잡도
- **시간 복잡도**: O(n log n) - 힙 생성에 O(n), 최대 n-1번의 음식 섞기 연산에서 각각 O(log n)의 시간이 소요됩니다.
- **공간 복잡도**: O(n) - 입력 배열 크기만큼의 힙 공간이 필요합니다.

## 엣지 케이스 처리
- 힙의 크기가 1이 되었는데도 스코빌 지수가 K 미만인 경우, -1을 반환합니다.
- 처음부터 모든 음식의 스코빌 지수가 K 이상인 경우, 0을 반환합니다.

## 최적화 고려사항
이 문제에서 사용한 접근법은 이미 최적화되어 있습니다. 최소 힙을 사용하면 가장 작은 두 값을 O(log n) 시간에 찾아 처리할 수 있습니다. 다른 자료구조(예: 정렬된 배열, 이진 탐색 트리 등)를 사용하면 더 비효율적일 수 있습니다.

## 면접 팁
이 문제는 힙 자료구조의 이해와 활용 능력을 테스트합니다. 면접에서는 다음 사항을 강조하면 좋습니다:

1. **문제 이해**: 문제의 요구사항을 정확히 이해하고 있음을 보여주세요.
2. **자료구조 선택**: 최소 힙을 선택한 이유와 이 문제에서의 적합성을 설명하세요.
3. **알고리즘 설명**: 음식을 섞는 과정과 종료 조건을 명확히 설명하세요.
4. **시간 복잡도 분석**: 각 연산의 시간 복잡도와 전체 알고리즘의 복잡도를 분석해 보세요.
5. **엣지 케이스 고려**: 모든 음식을 K 이상으로 만들 수 없는 경우를 어떻게 감지하는지 설명하세요.

이 문제는 우선순위 큐(힙)의 개념을 이해하고 있는지 확인하는 좋은 문제입니다. Python의 heapq 모듈에 대한 이해도 중요합니다.