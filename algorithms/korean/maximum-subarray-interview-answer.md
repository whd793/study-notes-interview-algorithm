# Maximum Subarray(최대 부분 배열) 문제에 대한 인터뷰 답변

## 문제 설명
정수 배열이 주어졌을 때, 가장 큰 합을 가지는 연속적인 부분 배열을 찾는 문제입니다. 배열의 원소는 양수와 음수가 모두 포함될 수 있습니다.

## 접근 방법
이 문제는 동적 프로그래밍(DP)과 카데인 알고리즘(Kadane's Algorithm)으로 효율적으로 해결할 수 있습니다. 카데인 알고리즘의 핵심 아이디어는 각 위치에서 끝나는 최대 부분 배열의 합을 계산하는 것입니다.

알고리즘 흐름은 다음과 같습니다:
1. 두 변수를 초기화합니다: `current_sum`(현재 위치까지의 최대 부분합)과 `max_sum`(전체 최대 부분합).
2. 배열을 순회하면서 각 원소에 대해:
   - `current_sum`을 갱신합니다: `current_sum = max(current_sum + nums[i], nums[i])`
   - 이는 현재 원소를 이전 부분합에 더할지, 아니면 새로운 부분 배열을 시작할지 결정합니다.
   - `max_sum`을 갱신합니다: `max_sum = max(max_sum, current_sum)`

## 코드 구현
```python
def max_subarray(nums):
    # 예외 처리: 빈 배열인 경우
    if not nums:
        return 0
    
    # 현재까지의 최대 부분합과 전체 최대 부분합 초기화
    current_sum = max_sum = nums[0]
    
    # 두 번째 원소부터 순회
    for i in range(1, len(nums)):
        # 현재 위치에서 끝나는 최대 부분합 계산
        # (이전 부분합 + 현재 원소) vs (새로운 부분 배열 시작)
        current_sum = max(nums[i], current_sum + nums[i])
        
        # 전체 최대 부분합 갱신
        max_sum = max(max_sum, current_sum)
    
    return max_sum
```

## 시간 및 공간 복잡도
- 시간 복잡도: O(n) - 배열을 한 번만 순회합니다.
- 공간 복잡도: O(1) - 추가 배열 없이 상수 공간만 사용합니다.

## 분할 정복 접근법
이 문제는 분할 정복(Divide and Conquer) 방법으로도 해결할 수 있습니다. 배열을 반으로 나누고, 최대 부분 배열이 세 가지 경우 중 하나에 속한다고 생각합니다:
1. 왼쪽 절반에만 있는 경우
2. 오른쪽 절반에만 있는 경우
3. 중간을 가로지르는 경우

하지만 이 방법은 시간 복잡도가 O(n log n)으로 카데인 알고리즘보다 효율성이 떨어집니다.

## 엣지 케이스 처리
- 빈 배열: 예외 처리 또는 0 반환 (문제 요구사항에 따라 다름)
- 모든 원소가 음수인 경우: 가장 큰 원소 하나만 선택하는 것이 최적

## 최적화 고려사항
카데인 알고리즘은 이미 최적화된 알고리즘입니다. 하지만 최대 부분 배열의 시작과 끝 인덱스도 함께 반환해야 하는 경우, 약간의 수정이 필요합니다.

이 문제는 동적 프로그래밍의 기본 개념을 테스트하는 중요한 문제입니다. 면접에서는 문제 해결 과정과 알고리즘의 직관적인 이해를 명확히 설명하는 것이 중요합니다.