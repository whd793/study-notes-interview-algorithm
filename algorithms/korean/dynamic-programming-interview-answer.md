# 동적 프로그래밍(Dynamic Programming)에 대한 인터뷰 답변

## 동적 프로그래밍이란?
동적 프로그래밍(DP)은 복잡한 문제를 간단한 하위 문제로 나누어 해결하고, 하위 문제의 결과를 저장하여 중복 계산을 피하는 알고리즘 설계 기법입니다. 이 방법은 특히 최적화 문제를 해결할 때 효과적입니다.

## 동적 프로그래밍의 핵심 원리
1. **최적 부분 구조(Optimal Substructure)**: 문제의 최적 해결책이 하위 문제의 최적 해결책으로 구성됩니다.
2. **중복되는 하위 문제(Overlapping Subproblems)**: 같은 하위 문제가 여러 번 발생하며, 그 결과를 재사용할 수 있습니다.

## 동적 프로그래밍 구현 방법
동적 프로그래밍은 주로 두 가지 방식으로 구현합니다:

### 1. 하향식 접근법(Top-down Approach) - 메모이제이션(Memoization)
재귀 함수를 사용하여 문제를 해결하되, 각 하위 문제의 결과를 메모리에 저장(메모이제이션)하여 중복 계산을 방지합니다.

```python
# 피보나치 수열의 하향식 DP 구현 예시
def fibonacci_top_down(n, memo=None):
    if memo is None:
        memo = {}
    
    # 기저 조건
    if n <= 1:
        return n
    
    # 이미 계산된 값이 있으면 재사용
    if n in memo:
        return memo[n]
    
    # 값 계산 및 저장
    memo[n] = fibonacci_top_down(n-1, memo) + fibonacci_top_down(n-2, memo)
    return memo[n]
```

### 2. 상향식 접근법(Bottom-up Approach) - 타뷸레이션(Tabulation)
반복문을 사용하여 작은 하위 문제부터 차례로 해결하고, 결과를 테이블(배열)에 저장합니다.

```python
# 피보나치 수열의 상향식 DP 구현 예시
def fibonacci_bottom_up(n):
    # 기저 조건 처리
    if n <= 1:
        return n
    
    # DP 테이블 초기화
    dp = [0] * (n + 1)
    dp[1] = 1
    
    # 작은 문제부터 차례로 해결
    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    
    return dp[n]
```

## 동적 프로그래밍의 적용 조건
1. 문제가 최적 부분 구조를 가져야 합니다.
2. 문제에 중복되는 하위 문제가 있어야 합니다.
3. 일반적으로 최적화 문제(최대값, 최소값 등)나 경우의 수를 구하는 문제에 적합합니다.

## 동적 프로그래밍 문제 해결 접근법
1. **문제의 상태(state) 정의**: DP[i], DP[i][j] 등이 어떤 의미를 갖는지 명확히 정의합니다.
2. **초기 상태(base case) 설정**: 가장 작은 하위 문제의 해결책을 설정합니다.
3. **상태 전이 방정식(recurrence relation) 도출**: 하위 문제와 현재 문제 사이의 관계식을 세웁니다.
4. **구현 방식 선택**: 하향식(메모이제이션) 또는 상향식(타뷸레이션) 접근법을 선택합니다.
5. **최종 답 계산**: 원래 문제의 답을 계산합니다.

## 대표적인 동적 프로그래밍 문제 유형
1. **0/1 배낭 문제(Knapsack Problem)**: 제한된 무게 내에서 최대 가치를 선택하는 문제
2. **최장 증가 부분 수열(LIS)**: 수열에서 가장 긴 증가하는 부분 수열 찾기
3. **최소 편집 거리(Edit Distance)**: 두 문자열 간의 최소 편집 연산 수 구하기
4. **격자 경로 문제(Grid Problems)**: 격자에서 특정 지점에 도달하는 경로의 수 또는 최적 경로 찾기
5. **동전 교환 문제(Coin Change)**: 특정 금액을 만들기 위한 동전 조합의 경우의 수 또는 최소 동전 개수 구하기

## 시간 및 공간 복잡도
- **시간 복잡도**: 일반적으로 O(n) 또는 O(n²) 등 다항 시간에 해결 가능합니다. 문제의 상태 수 × 각 상태에서의 전이 비용으로 계산됩니다.
- **공간 복잡도**: 모든 상태를 저장하므로 일반적으로 O(n) 또는 O(n²) 등의 공간이 필요합니다. 때로는 공간 최적화를 통해 개선 가능합니다.

## 면접 팁
- 동적 프로그래밍 문제를 해결할 때는 문제의 상태와 상태 전이 방정식을 명확히 설명하는 것이 중요합니다.
- 초기 상태(기저 조건)를 정확히 설정해야 합니다.
- 가능하면 작은 예시로 알고리즘을 시뮬레이션하여 정확성을 검증하세요.
- 하향식과 상향식 접근법의 장단점을 이해하고, 상황에 맞게 선택할 수 있어야 합니다.
- 시간과 공간 복잡도를 분석할 수 있어야 합니다.

동적 프로그래밍은 알고리즘 문제 해결의 강력한 도구이며, 많은 최적화 문제에 적용 가능합니다.